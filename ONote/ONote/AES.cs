using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Security.Cryptography;

namespace ONote
{
    class AES
    {
        private byte[] Password;              // 密码字节
        private int SaltByteNum;              // 盐的字节数
        private int KeySize;                  // 密钥的位数
        private int KeyByteNum;               // 密钥字节数
        private int KeyColumn;                // 密钥矩阵的列数（行固定为4）
        private int EncryptRound;             // 加密的轮次
        private int SubKeyNum;                // 扩展密钥后的子密钥个数
        private int SubKeyAllColumn;          // 扩展密钥后的子密钥矩阵总列数（行固定为4）
        private int BlockSize;                // AES处理的块位数
        private int BlockByteNum;             // AES处理的块字节数
        private Encoding Encode;              // AES采用的编码

        // 字节替代表
        private static byte[] SBOX =
        {
            0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
            0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
            0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
            0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
            0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
            0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
            0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
            0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
            0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
            0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
            0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
            0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
            0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
            0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
            0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
            0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
        };

        // 字节代替的逆表
        private static byte[] INV_SBOX =
        {
            0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
            0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
            0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
            0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
            0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
            0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
            0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
            0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
            0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
            0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
            0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
            0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
            0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
            0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
            0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
            0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
        };

        // 有限域中的乘2运算结果表
        private static byte[] MUL_BY_2 =
        {
            0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,
            0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e,
            0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,
            0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e,
            0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e,
            0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,
            0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,
            0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe,
            0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05,
            0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25,
            0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45,
            0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65,
            0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85,
            0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5,
            0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5,
            0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5
        };

        // 有限域中的乘4运算结果表
        private static byte[] MUL_BY_3 =
        {
            0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11,
            0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21,
            0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71,
            0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41,
            0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1,
            0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1,
            0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1,
            0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81,
            0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a,
            0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba,
            0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea,
            0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda,
            0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a,
            0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a,
            0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a,
            0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a
        };

        // 有限域中的乘9运算结果表
        private static byte[] MUL_BY_9 =
        {
            0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77,
            0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7,
            0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c,
            0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc,
            0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01,
            0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91,
            0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a,
            0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa,
            0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b,
            0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b,
            0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0,
            0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30,
            0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed,
            0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d,
            0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6,
            0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46
        };

        // 有限域中的乘11运算结果表
        private static byte[] MUL_BY_11 =
        {
            0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69,
            0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9,
            0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12,
            0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2,
            0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f,
            0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f,
            0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4,
            0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c, 0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54,
            0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e,
            0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e,
            0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5,
            0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55,
            0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68,
            0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8,
            0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13,
            0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3
        };

        // 有限域中的乘13运算结果表
        private static byte[] MUL_BY_13 =
        {
            0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b,
            0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b,
            0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0,
            0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20,
            0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26,
            0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6,
            0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d,
            0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d,
            0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91,
            0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41,
            0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a,
            0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa,
            0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc,
            0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c,
            0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47,
            0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97
        };

        // 有限域中的乘14运算结果表
        private static byte[] MUL_BY_14 =
        {
            0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a,
            0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba,
            0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81,
            0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61,
            0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7,
            0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17,
            0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c,
            0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc,
            0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b,
            0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb,
            0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0,
            0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20,
            0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6,
            0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56,
            0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d,
            0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d
        };

        // 有限域中的2^(i-1)次方幂表
        private static byte[] RCON =
        {
            0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 
            0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 
            0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 
            0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 
            0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 
            0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 
            0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 
            0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 
            0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 
            0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 
            0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 
            0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 
            0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 
            0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 
            0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 
            0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d
        };


        /// <summary>指定密码构建AES对象，密钥默认为256位，盐默认为32字节，编码默认为UTF8</summary>
        /// <param name="password">密码</param>
        /// <returns>AES对象</returns>
        public AES(string password) : this(password, 256, 32, Encoding.UTF8) { }

        /// <summary>指定密码，密钥位数构建AES对象，盐默认为32字节，编码默认为UTF8</summary>
        /// <param name="password">密码</param>
        /// <param name="keySize">密钥位数</param>
        /// <returns>AES对象</returns>
        public AES(string password, int keySize) : this(password, keySize, 32, Encoding.UTF8) { }

        /// <summary>指定密码，密钥位数，盐字节数构建AES对象，编码默认为UTF8</summary>
        /// <param name="password">密码</param>
        /// <param name="keySize">密钥位数</param>
        /// <param name="saltByteNum">盐的字节数</param>
        /// <returns>AES对象</returns>
        public AES(string password, int keySize, int saltByteNum) : this(password, keySize, saltByteNum, Encoding.UTF8) { }

        /// <summary>指定密码，密钥位数，盐字节数，编码构建AES对象</summary>
        /// <param name="password">密码</param>
        /// <param name="keySize">密钥位数</param>
        /// <param name="saltByteNum">盐的字节数</param>
        /// <param name="encode">AES采用的编码</param>
        /// <returns>AES对象</returns>
        public AES(string password, int keySize, int saltByteNum, Encoding encode)
        {
            this.Password = encode.GetBytes(password);
            this.KeySize = keySize;
            this.SaltByteNum = saltByteNum;
            this.Encode = encode;
            this.KeyByteNum = KeySize / 8;
            this.KeyColumn = KeyByteNum / 4;
            this.EncryptRound = KeySize == 256 ? 14 : KeySize == 192 ? 12 : 10;
            this.SubKeyNum = (EncryptRound + 1);
            this.SubKeyAllColumn = 4 * SubKeyNum;
            this.BlockSize = 128;
            this.BlockByteNum = BlockSize / 8;
        }

        /// <summary>加密明文串，返回的密文串用Base64编码</summary>
        /// <param name="plaintext">明文</param>
        /// <returns>密文</returns>
        public string Encrypt(string plaintext)
        {
            return Convert.ToBase64String(Encrypt(Encode.GetBytes(plaintext)));
        }

        /// <summary>字节流加密</summary>
        /// <param name="stream">字节流</param>
        /// <returns>加密流</returns>
        public byte[] Encrypt(byte[] stream)
        {
            int i;
            byte[] salt = new byte[SaltByteNum];
            byte[] key = new byte[KeyByteNum];
            byte[] iv = new byte[BlockByteNum];

            // 盐为随机字节流
            new Random().NextBytes(salt);

            // 从password和salt中生成key和iv
            GenKeyAndIV(Password, salt, key, iv);

            // 扩展密钥并获取子密钥
            byte[] expandKey = KeyExpansion(key);
            byte[][,] subKey = new byte[SubKeyNum][,];

            // 16个字节为一个子密钥，并把子密钥转为矩阵状态
            for (i = 0; i < subKey.Length; i++)
            {
                subKey[i] = ByteArrayToMatrix(SubByteArray(expandKey, 16 * i, 16));
            }

            // 调整字节流，进行填充处理
            byte[] paddingStream = PaddingStream(stream);

            // 状态矩阵
            byte[][,] state = new byte[paddingStream.Length / 16][,];

            // 把字节流放到状态矩阵
            for (i = 0; i < state.Length; i++)
            {
                state[i] = ByteArrayToMatrix(SubByteArray(paddingStream, 16 * i, 16));
            }

            // 把iv转为矩阵状态
            byte[,] ivState = ByteArrayToMatrix(iv);

            // 以CBC模式对每一个状态矩阵进行加密
            Xor(state[0], ivState);
            EncryptUnit(state[0], subKey);

            for (i = 1; i < state.Length; i++)
            {
                Xor(state[i], state[i - 1]);
                EncryptUnit(state[i], subKey);
            }

            // 加密后的字节数组
            byte[] encryptedBytes = new byte[paddingStream.Length];

            // 把加密后的状态矩阵放到加密字节数组中
            for (i = 0; i < state.Length; i++)
            {
                Array.Copy(MatrixToByteArray(state[i]), 0, encryptedBytes, 16 * i, 16);
            }

            // Print(encryptedBytes);

            // 返回盐和加密后的字节数组
            return MergeByteArray(salt, encryptedBytes);
        }

        /// <summary>加密单元</summary>
        /// <param name="state">状态矩阵，即4*4的字节矩阵</param>
        /// <param name="subKey">各轮子密钥</param>
        private void EncryptUnit(byte[,] state, byte[][,] subKey)
        {
            int i;

            // 状态与初始密钥作首轮异或
            AddRoundKey(state, subKey[0]);

            // 根据不同的密钥位数作不同的轮次加密
            for (i = 1; i < EncryptRound; i++)
            {
                SubBytes(state);    // 字节替代
                ShiftRows(state);   // 行移动
                MixColumns(state);  // 列混淆
                AddRoundKey(state, subKey[i]);  // 与子密钥异或
            }

            // 最后一轮不作列混淆，所以要单放出来
            SubBytes(state);
            ShiftRows(state);
            AddRoundKey(state, subKey[EncryptRound]);
        }

        /// <summary>状态矩阵与密钥状态矩阵异或</summary>
        /// <param name="state">状态矩阵，即4*4的字节矩阵</param>
        /// <param name="keyState">密钥状态矩阵</param>
        private void AddRoundKey(byte[,] state, byte[,] keyState)
        {
            int r, c;

            for (r = 0; r < 4; r++)
            {
                for (c = 0; c < 4; c++)
                {
                    state[r, c] ^= keyState[r, c];
                }
            }
        }

        /// <summary>对状态矩阵进行字节替换，即有限域的逆元代替与仿射变换过程</summary>
        /// <param name="state">状态矩阵，即4*4的字节矩阵</param>
        private void SubBytes(byte[,] state)
        {
            int r, c;

            for (r = 0; r < 4; r++)
            {
                for (c = 0; c < 4; c++)
                {
                    state[r, c] = SBOX[state[r, c]];
                }
            }
        }

        /// <summary>对状态矩阵进行行移动，第0行不动，第1行向左移1字节，以此类推</summary>
        /// <param name="state">状态矩阵，即4*4的字节矩阵</param>
        private void ShiftRows(byte[,] state)
        {
            int r, c;
            byte[] t = new byte[4];

            for (r = 1; r < 4; r++)
            {
                for (c = 0; c < 4; c++)
                {
                    t[c] = state[r, (r + c) % 4];
                }
                for (c = 0; c < 4; c++)
                {
                    state[r, c] = t[c];
                }
            }
        }

        /// <summary>对状态矩阵进行列混淆，即与一个特定矩阵相乘的过程</summary>
        /// <param name="state">状态矩阵，即4*4的字节矩阵</param>
        private void MixColumns(byte[,] state)
        {
            int r, c;
            byte[] a = new byte[4];

            for (c = 0; c < 4; c++)
            {
                // a保存状态的一列
                for (r = 0; r < 4; r++)
                {
                    a[r] = state[r, c];
                }
                // state[0][c] = 2 * a[0] + 3 * a[1] + a[2] + a[3]
                // 以此类推...在这里+是异或操作，乘已用表优化
                state[0, c] = (byte)(MUL_BY_2[a[0]] ^ MUL_BY_3[a[1]] ^ a[2] ^ a[3]);
                state[1, c] = (byte)(a[0] ^ MUL_BY_2[a[1]] ^ MUL_BY_3[a[2]] ^ a[3]);
                state[2, c] = (byte)(a[0] ^ a[1] ^ MUL_BY_2[a[2]] ^ MUL_BY_3[a[3]]);
                state[3, c] = (byte)(MUL_BY_3[a[0]] ^ a[1] ^ a[2] ^ MUL_BY_2[a[3]]);
            }
        }

        // <summary>解密密文串</summary>
        /// <param name="ciphertext">密文</param>
        /// <returns>明文</returns>
        public string Decrypt(string ciphertext)
        {
            return Encode.GetString(Decrypt(Convert.FromBase64String(ciphertext)));
        }

        /// <summary>字节流解密</summary>
        /// <param name="stream">字节流</param>
        /// <returns>解密流</returns>
        public byte[] Decrypt(byte[] stream)
        {
            int i;
            byte[] salt = SubByteArray(stream, 0, SaltByteNum);
            byte[] key = new byte[KeyByteNum];
            byte[] iv = new byte[BlockByteNum];

            // 从password和salt中生成key和iv
            GenKeyAndIV(Password, salt, key, iv);

            // 扩展密钥并获取子密钥
            byte[] expandKey = KeyExpansion(key);
            byte[][,] subKey = new byte[SubKeyNum][,];

            // 16个字节为一个子密钥，并把子密钥转为矩阵状态
            for (i = 0; i < subKey.Length; i++)
            {
                subKey[i] = ByteArrayToMatrix(SubByteArray(expandKey, 16 * i, 16));
            }

            // 截取内容部分
            byte[] content = SubByteArray(stream, SaltByteNum, stream.Length - SaltByteNum);

            // 状态矩阵
            byte[][,] state = new byte[content.Length / 16][,];

            // 把内容字节流放到状态矩阵
            for (i = 0; i < state.Length; i++)
            {
                state[i] = ByteArrayToMatrix(SubByteArray(content, 16 * i, 16));
            }

            // 把iv转为矩阵状态
            byte[,] ivState = ByteArrayToMatrix(iv);

            // 以CBC模式从后面对每一个状态矩阵进行解密
            for (i = state.Length - 1; i > 0; i--)
            {
                DecryptUnit(state[i], subKey);
                Xor(state[i], state[i - 1]);
            }

            DecryptUnit(state[0], subKey);
            Xor(state[0], ivState);

            // 解密后的字节数组
            byte[] decryptedBytes = new byte[content.Length];

            // 把解密后的状态矩阵放到解密字节数组中
            for (i = 0; i < state.Length; i++)
            {
                Array.Copy(MatrixToByteArray(state[i]), 0, decryptedBytes, 16 * i, 16);
            }

            // 去掉加密时填充的字节并返回结果
            return SubByteArray(decryptedBytes, 0, decryptedBytes.Length - decryptedBytes[decryptedBytes.Length - 1]);
        }

        /// <summary>解密单元</summary>
        /// <param name="state">状态矩阵，即4*4的字节矩阵</param>
        /// <param name="subKey">各轮子密钥</param>
        private void DecryptUnit(byte[,] state, byte[][,] subKey)
        {
            int i;

            // 全部参照上面的加密反过来写就可以了
            AddRoundKey(state, subKey[EncryptRound]);
            InvShiftRows(state);
            InvSubBytes(state);

            for (i = EncryptRound - 1; i > 0; i--)
            {
                AddRoundKey(state, subKey[i]);
                InvMixColumns(state);
                InvShiftRows(state);
                InvSubBytes(state);
            }

            AddRoundKey(state, subKey[0]);
        }

        /// <summary>状态矩阵字节替代的逆操作</summary>
        /// <param name="state">状态矩阵，即4*4的字节矩阵</param>
        private void InvSubBytes(byte[,] state)
        {
            int r, c;

            for (r = 0; r < 4; r++)
            {
                for (c = 0; c < 4; c++)
                {
                    state[r, c] = INV_SBOX[state[r, c]];
                }
            }
        }

        /// <summary>状态矩阵行移动的逆操作</summary>
        /// <param name="state">状态矩阵，即4*4的字节矩阵</param>
        private void InvShiftRows(byte[,] state)
        {
            int r, c;
            byte[] t = new byte[4];

            for (r = 1; r < 4; r++)
            {
                for (c = 0; c < 4; c++)
                {
                    t[(r + c) % 4] = state[r, c];
                }

                for (c = 0; c < 4; c++)
                {
                    state[r, c] = t[c];
                }
            }
        }

        /// <summary>列混淆的逆操作</summary>
        /// <param name="state">状态矩阵，即4*4的字节矩阵</param>
        private void InvMixColumns(byte[,] state)
        {
            int r, c;
            byte[] a = new byte[4];

            for (c = 0; c < 4; c++)
            {
                for (r = 0; r < 4; r++)
                {
                    a[r] = state[r, c];
                }

                state[0, c] = (byte)(MUL_BY_14[a[0]] ^ MUL_BY_11[a[1]] ^ MUL_BY_13[a[2]] ^ MUL_BY_9[a[3]]);
                state[1, c] = (byte)(MUL_BY_9[a[0]] ^ MUL_BY_14[a[1]] ^ MUL_BY_11[a[2]] ^ MUL_BY_13[a[3]]);
                state[2, c] = (byte)(MUL_BY_13[a[0]] ^ MUL_BY_9[a[1]] ^ MUL_BY_14[a[2]] ^ MUL_BY_11[a[3]]);
                state[3, c] = (byte)(MUL_BY_11[a[0]] ^ MUL_BY_13[a[1]] ^ MUL_BY_9[a[2]] ^ MUL_BY_14[a[3]]);
            }
        }

        /// <summary>从密码和盐中生成密钥和初始向量</summary>
        /// <param name="password">密码</param>
        /// <param name="salt">盐</param>
        /// <param name="key">密钥</param>
        /// <param name="iv">初始向量</param>
        private void GenKeyAndIV(byte[] password, byte[] salt, byte[] key, byte[] iv)
        {
            // byte[] passwordAndSalt = password;  // for test
            byte[] passwordAndSalt = MergeByteArray(password, salt);

            MD5 md5 = MD5.Create();
            byte[] t1 = md5.ComputeHash(passwordAndSalt);
            byte[] t2 = md5.ComputeHash(MergeByteArray(t1, passwordAndSalt));
            byte[] t3 = md5.ComputeHash(MergeByteArray(t2, passwordAndSalt));

            if (KeySize == 128)
            {
                Array.Copy(t1, 0, key, 0, 16);
                Array.Copy(t2, 0, iv, 0, 16);
            }
            else if (KeySize == 256)
            {
                Array.Copy(t1, 0, key, 0, 16);
                Array.Copy(t2, 0, key, 16, 16);
                Array.Copy(t3, 0, iv, 0, 16);
            }
            else
            {
                Array.Copy(t1, 0, key, 0, 16);
                Array.Copy(t2, 0, key, 16, 8);
                Array.Copy(t2, 8, iv, 0, 8);
                Array.Copy(t3, 0, iv, 8, 8);
            }
        }

        /// <summary>密钥扩展</summary>
        /// <param name="key">密钥</param>
        /// <returns>扩展密钥</returns>
        private byte[] KeyExpansion(byte[] key)
        {
            int i, r, c;

            // 扩展密钥的字节矩阵
            byte[,] matrix = new byte[4, SubKeyAllColumn];

            // 把原始的密钥直接放到矩阵中，以先列后行的方式存放
            for (c = 0; c < KeyColumn; c++)
            {
                for (r = 0; r < 4; r++)
                {
                    matrix[r, c] = key[4 * c + r];
                }
            }

            byte temp;
            byte[] t = new byte[4];  // t用于记录字节矩阵的一列

            // 密钥矩阵扩展
            // PS: 对于128, 192位密钥，处理可统一，对于256位稍不同
            for (i = 1; c < SubKeyAllColumn; c++)
            {
                for (r = 0; r < 4; r++)
                {
                    t[r] = matrix[r, c - 1];  // t记录matrix矩阵的上一列
                }

                if (c % KeyColumn == 0)
                {
                    // 把t循环左移一字节
                    // 然后对t的每个字节用SBOX作字节替换
                    // 最后对t的第一个字节与RCON异或
                    temp = t[0];
                    for (r = 0; r < 3; r++)
                        t[r] = SBOX[t[(r + 1) % 4]];
                    t[3] = SBOX[temp];
                    t[0] ^= RCON[i++ - 1];
                }

                // 如果密钥为256位，并且 c % KeyColumn == 4 则把t作SBOX字节替换
                else if (KeySize == 256 && c % KeyColumn == 4)
                {
                    for (r = 0; r < 4; r++)
                    {
                        t[r] = SBOX[t[r]];
                    }
                }

                // 最后扩展密钥矩阵的新列 = 矩阵的[c-keyColumn]列 ^ t表示的列
                for (r = 0; r < 4; r++)
                {
                    matrix[r, c] = (byte)(matrix[r, c - KeyColumn] ^ t[r]);
                }
            }

            // 扩展密钥
            byte[] expandKey = new byte[16 * SubKeyNum];

            // 把扩展后的密钥矩阵以每16个字节（4*4矩阵）的方式分配给expandKey
            for (i = 0; i < SubKeyNum; i++)
            {
                for (c = 0; c < 4; c++)
                {
                    for (r = 0; r < 4; r++)
                    {
                        expandKey[16 * i + 4 * c + r] = matrix[r, 4 * i + c];
                    }
                }
            }

            // Print(expandKey);

            return expandKey;
        }

        /// <summary>填充字节流</summary>
        /// <param name="stream">字节流</param>
        /// <returns>填充后的字节流</returns>
        private byte[] PaddingStream(byte[] stream)
        {
            int remainder = stream.Length % 16;

            // 若字节数是16的倍数则填充16，否则填充16-remainder
            byte padding = (byte)(remainder == 0 ? 16 : 16 - remainder);

            byte[] result = new byte[stream.Length + padding];

            Array.Copy(stream, 0, result, 0, stream.Length);

            for (int i = stream.Length; i < result.Length; i++)
            {
                result[i] = padding;
            }

            return result;
        }

        /// <summary>合并字节数组</summary>
        /// <param name="a">字节数组1</param>
        /// <param name="b"> 字节数组2</param>
        /// <returns>合并后的新字节数组</returns>
        private byte[] MergeByteArray(byte[] a, byte[] b)
        {
            byte[] c = new byte[a.Length + b.Length];

            Array.Copy(a, 0, c, 0, a.Length);
            Array.Copy(b, 0, c, a.Length, b.Length);

            return c;
        }

        /// <summary>获取子字节数组</summary>
        /// <param name="srcByteArray">源字节数组</param>
        /// <param name="startIndex">起始下标</param>
        /// <param name="length">长度</param>
        /// <returns>子字节数组</returns>
        private byte[] SubByteArray(byte[] srcByteArray, int startIndex, int length)
        {
            byte[] result = new byte[length];

            for (int i = 0; i < length; i++)
            {
                result[i] = srcByteArray[startIndex + i];
            }

            return result;
        }

        /// <summary>把4*4的字节矩阵数组转为字节数组</summary>
        /// <param name="matrix">字节矩阵</param>
        /// <returns>字节数组</returns>
        private byte[] MatrixToByteArray(byte[,] matrix)
        {
            int r, c;
            byte[] byteArray = new byte[16];

            for (c = 0; c < 4; c++)
            {
                for (r = 0; r < 4; r++)
                {
                    byteArray[4 * c + r] = matrix[r, c];
                }
            }

            return byteArray;
        }

        /// <summary>把字节数组转为4*4的字节矩阵数组</summary>
        /// <param name="byteArray">字节数组</param>
        /// <returns>字节矩阵数组</returns>
        private byte[,] ByteArrayToMatrix(byte[] byteArray)
        {
            int r, c;

            byte[,] matrix = new byte[4, 4];

            for (c = 0; c < 4; c++)
            {
                for (r = 0; r < 4; r++)
                {
                    matrix[r, c] = byteArray[c * 4 + r];
                }
            }

            return matrix;
        }

        /// <summary>异或2个字节矩阵，结果保存在第一个参数</summary>
        /// <param name="a">字节矩阵1</param>
        /// <param name="b">字节矩阵2</param>
        private void Xor(byte[,] a, byte[,] b)
        {
            int r, c;
            for (r = 0; r < 4; r++)
            {
                for (c = 0; c < 4; c++)
                {
                    a[r, c] ^= b[r, c];
                }
            }
        }

        /// <summary>以矩阵的形式打印字节数组，每16个字节为一个矩阵</summary>
        /// <param name="state">字节数组</param>
        private void Print(byte[] bytes)
        {
            int i, r, c;

            for (i = 0; i < bytes.Length / 16; i++)
            {
                for (r = 0; r < 4; r++)
                {
                    for (c = 0; c < 4; c++)
                    {
                        Console.Write(Convert.ToString(bytes[16 * i + 4 * c + r], 16) + " ");
                    }
                    Console.WriteLine();
                }
                Console.WriteLine();
            }
        }
    }
}
